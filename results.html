<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Analyse des occupations - Résultats</title>
        <link rel="stylesheet" href="style.css"> <!-- On peut réutiliser le même style si désiré, ou en créer un nouveau -->
        <style>
            /* Styles spécifiques aux résultats */
            #resultsChartContainer {
                width: 100%;
                max-width: 800px; /* Limiter la largeur du graphique */
                margin: 20px auto;
                background-color: #fff;
                padding: 20px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                border-radius: 8px;
            }

            #resultsSummary {
                margin-top: 30px;
                border-top: 1px solid #eee;
                padding-top: 20px;
            }

            #resultsSummary h2 {
                text-align: center;
                margin-bottom: 20px;
                color: #0056b3;
            }

            .occupation-summary {
                margin-bottom: 15px;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                background-color: #fafafa;
            }

            .occupation-summary strong {
                color: #333;
            }

            .occupation-summary p {
                margin: 5px 0;
                font-size: 0.95em;
            }

            .no-data {
                text-align: center;
                color: red;
                font-weight: bold;
                margin-top: 50px;
            }

            /* Ajouter des styles pour les axes et le fond du graphique si nécessaire,
                mais Chart.js gère une bonne partie du rendu par défaut */

            /* Inclure le CSS de la page questionnaire ici si vous n'utilisez pas style.css */
            /* Si vous avez tout le CSS du questionnaire dans test.html, vous pouvez le copier ici,
            ou mieux, mettre tout le CSS commun dans style.css et le lier aux deux pages.
            Pour simplifier, j'ai supposé que style.css contient les styles communs. */

        </style>
        <!-- Inclure la librairie Chart.js -->

        <!-- Inclure le script pour les résultats -->
        <script src="results.js" defer></script>
        <!-- La librairie Chartjs-plugin-datalabels est utile pour afficher les noms des points,
            mais nécessite une configuration JS. On peut l'ajouter plus tard si besoin.
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
        -->
    </head>
    <body>

        <div class="container">
            <h1>Résultats de votre analyse d'occupations</h1>

            <div id="resultsChartContainer">
                <canvas id="resultsChart"></canvas> <!-- Le graphique sera dessiné ici -->
            </div>


            <div id="resultsSummary">
                <h2>Récapitulatif de vos réponses</h2>
                <!-- Le récapitulatif sera inséré ici par JavaScript -->
            </div>

            <div class="no-data" style="display: none;">
                Aucune donnée de questionnaire trouvée. Veuillez d'abord remplir le questionnaire.
            </div>
        </div>


        <script>
            // Liste des occupations (doit correspondre exactement à l'ordre du questionnaire)
            // Liste des occupations (doit correspondre exactement à l'ordre du questionnaire)
            const occupations = [
                "Temps passé avec le partenaire",
                "S'engager avec les enfants, les parents, les frères et sœurs",
                "Temps passé avec ses collègues ou partenaires",
                "Du temps avec des amis",
                "Exercice, physiothérapie",
                "Psychothérapie, méditation",
                "Prendre en compte les conséquences en amont de toute action",
                "Pratique religieuse",
                "Appartenance à des clubs locaux",
                "Activisme bénévole",
                "Travail",
                "Cours, formations",
                "Planifier l'investissement",
                "Lecture, Objets de collection",
                "Réseaux sociaux, télévision, jeux vidéo",
                "Vacances, théâtre, événements sportifs",
                "Manger, dormir",
                "Trajets domicile-travail, tâches ménagères"
            ];

            document.addEventListener('DOMContentLoaded', function() {
                const resultsChartCanvas = document.getElementById('resultsChart');
                const resultsSummaryDiv = document.getElementById('resultsSummary');
                const noDataDiv = document.querySelector('.no-data'); // Message "Aucune donnée"
                const chartContainer = document.getElementById('resultsChartContainer'); // Conteneur du canvas

                // 1. Récupérer les données du stockage local
                const storedResults = localStorage.getItem('occupationResults');

                if (!storedResults) {
                    // Afficher un message si aucune donnée n'est trouvée
                    if(resultsSummaryDiv) resultsSummaryDiv.style.display = 'none';
                    if(chartContainer) chartContainer.style.display = 'none'; // Cacher le conteneur du graphique si trouvé
                    if(noDataDiv) noDataDiv.style.display = 'block';
                    console.warn("Aucune donnée de questionnaire trouvée dans le stockage local.");
                    return; // Arrêter l'exécution du script
                }

                let occupationData = [];
                try {
                    // Parser les données JSON
                    occupationData = JSON.parse(storedResults);
                    console.log("Données brutes récupérées du stockage local:", occupationData); // Log des données brutes
                } catch (e) {
                    console.error("Erreur lors du parsing des données de Local Storage:", e);
                    if(resultsSummaryDiv) resultsSummaryDiv.innerHTML = "<p style='color: red; text-align: center;'>Erreur lors du chargement des données. Veuillez réessayer de remplir le questionnaire.</p>";
                    if(chartContainer) chartContainer.style.display = 'none';
                    if(noDataDiv) noDataDiv.style.display = 'none'; // Cacher le message "no data" standard
                    return; // Arrêter l'exécution
                }

                // 2. Afficher le récapitulatif
                if (occupationData && occupationData.length > 0) {
                    if(resultsSummaryDiv) {
                        resultsSummaryDiv.innerHTML = '<h2>Récapitulatif de vos réponses</h2>'; // Réinitialiser le titre si nécessaire
                        occupationData.forEach(item => {
                            const summaryElement = document.createElement('div');
                            summaryElement.classList.add('occupation-summary'); // Ajouter une classe pour le style
                            summaryElement.innerHTML = `
                                <p><strong>${item.name}</strong></p>
                                <p>Temps investi : ${item.time.charAt(0).toUpperCase() + item.time.slice(1)}</p> <!-- Afficher avec Majuscule -->
                                <p>Importance : ${item.importance}/10</p>
                                <p>Satisfaction : ${item.satisfaction}/10</p>
                            `;
                            resultsSummaryDiv.appendChild(summaryElement);
                        });
                    }
                    if(noDataDiv) noDataDiv.style.display = 'none'; // S'assurer que le message d'erreur est caché
                } else {
                    // Cas où storedResults existe mais le tableau est vide (improbable avec required, mais pour robustesse)
                    if(resultsSummaryDiv) resultsSummaryDiv.style.display = 'none';
                    if(chartContainer) chartContainer.style.display = 'none';
                    if(noDataDiv) {
                        noDataDiv.style.display = 'block';
                        noDataDiv.textContent = "Aucune réponse valide n'a été enregistrée. Veuillez remplir le questionnaire.";
                    }
                    console.warn("Les données récupérées sont vides.");
                    return;
                }

                // 3. Préparer les données pour le graphique
                // --- LOGIQUE POUR LA TAILLE DES POINTS ---
                // La taille du point (rayon 'r') sera influencée par les 3 variables.
                // Base de la taille définie par le temps investi:
                const timeBaseRadiusMap = {
                    'peu': 5,     // Petite base de rayon
                    'moyen': 10,  // Base moyenne
                    'beaucoup': 15 // Grosse base
                };

                // Facteur d'influence de la moyenne (Importance + Satisfaction) sur le rayon
                const impSatAdditionalRadiusFactor = 2; // Multiplie la moyenne (Imp+Sat)/2 par ce facteur

                // Tableau de couleurs pour distinguer les points
                const colors = [
                    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
                    '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78',
                    '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7'
                ];

                const chartData = occupationData.map((item, index) => {
                    // Calculer l'indice de couleur (cycle les couleurs si plus d'occupations que de couleurs)
                    const colorIndex = index % colors.length;

                    // --- Calcul du Rayon ('r') ---
                    const baseRadius = timeBaseRadiusMap[item.time] || 5; // Rayon de base selon le temps (5 par défaut)
                    const impSatAverage = (item.importance + item.satisfaction) / 2; // Moyenne Importance/Satisfaction (sur 10)

                    // Calculer le rayon supplémentaire basé sur la moyenne Imp/Sat
                    const additionalRadius = impSatAverage * impSatAdditionalRadiusFactor;

                    // Rayon final est la somme de la base temps et du rayon supplémentaire Imp/Sat
                    const finalRadius = baseRadius + additionalRadius;

                    // Optionnel : Clamper le rayon pour éviter des points trop petits ou trop grands
                    const minDisplayRadius = 5; // Taille minimale pour qu'on voie bien le point
                    const maxDisplayRadius = 30; // Taille maximale pour ne pas surcharger le graphique
                    const clampedRadius = Math.max(minDisplayRadius, Math.min(maxDisplayRadius, finalRadius));

                    console.log(`Occupation: ${item.name}, Temps: ${item.time}, Importance: ${item.importance}, Satisfaction: ${item.satisfaction}, Rayon calculé: ${clampedRadius}`);

                    return {
                        // X-axis: Satisfaction (0-10)
                        x: item.satisfaction,
                        // Y-axis: Importance (0-10)
                        y: item.importance,
                        // Bubble size: Use the calculated and clamped radius
                        r: clampedRadius,
                        // Store other info for tooltip (to display when hovering)
                        name: item.name,
                        time: item.time,
                        importance: item.importance,
                        satisfaction: item.satisfaction,
                        // Ajout de la couleur spécifique pour chaque point
                        backgroundColor: colors[colorIndex]
                    };
                });

                console.log("Données chartData envoyées à Chart.js:", chartData);

                // 4. Créer le graphique Chart.js
                if (resultsChartCanvas) {
                    // Définir une hauteur fixe pour le canvas pour agrandir l'espace du graphique
                    resultsChartCanvas.height = 500; // Hauteur en pixels - vous pouvez ajuster cette valeur
                    
                    const ctx = resultsChartCanvas.getContext('2d');

                    // Détruire le graphique existant si il y en a un (utile pour le développement)
                    if (window.myOccupationChart instanceof Chart) {
                        window.myOccupationChart.destroy();
                    }

                    window.myOccupationChart = new Chart(ctx, {
                        type: 'bubble', // Utiliser le type 'bubble' au lieu de 'scatter' pour avoir des points de tailles différentes
                        data: {
                            datasets: [{
                                label: 'Occupations',
                                data: chartData,
                                backgroundColor: chartData.map(item => item.backgroundColor),
                                borderColor: '#ffffff',
                                borderWidth: 1,
                                hoverBackgroundColor: chartData.map(item => item.backgroundColor),
                                hoverBorderColor: '#333'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false, // Permet de définir la taille manuellement
                            aspectRatio: 1.5, // Un rapport plus large que haut pour mieux étaler les points
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const item = context.raw;
                                            return `${item.name} (Temps: ${item.time.charAt(0).toUpperCase() + item.time.slice(1)}, Imp: ${item.y}/10, Sat: ${item.x}/10)`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: {
                                        display: true,
                                        text: 'Satisfaction',
                                        font: { size: 14, weight: 'bold' }
                                    },
                                    min: 0,
                                    max: 10,
                                    ticks: {
                                        stepSize: 1
                                    },
                                    grid: {
                                        borderColor: '#ccc',
                                        color: '#eee'
                                    }
                                },
                                y: {
                                    type: 'linear',
                                    position: 'left',
                                    title: {
                                        display: true,
                                        text: 'Importance',
                                        font: { size: 14, weight: 'bold' }
                                    },
                                    min: 0,
                                    max: 10,
                                    ticks: {
                                        stepSize: 1
                                    },
                                    grid: {
                                        borderColor: '#ccc',
                                        color: '#eee'
                                    }
                                }
                            },
                            layout: {
                                padding: {
                                    top: 30, right: 30, bottom: 30, left: 30 // Augmentation du padding pour donner plus d'espace
                                }
                            }
                        }
                    });
                } else {
                    console.error("Canvas pour le graphique 'resultsChart' introuvable.");
                    if(chartContainer) chartContainer.style.display = 'none';
                }
            });
        </script>
    </body>
</html>